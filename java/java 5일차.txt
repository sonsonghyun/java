43강 인터페이스 
객체를 만들 때 먼저 고려해야 하는 부분이 객체에 어떤 기능이 있는지 이다
클래스를 생성하고 Car객체를 만들어봄 이 때 자동차가 가져야 하는 기능이 무엇인지
이처럼 구현은 하지 않고, 기능들만 쭉 선언해서 가지고 있는 것을 인터페이스라고 한다

NEW > interface 클릭하고 
name 에 이름 적고 실행하면 

ex) 
package javaStudy;

public interface TV{
	(상세 코드)
}

상세코드에는 TV가 가져야 할 기능을 넣어야한다
기능이므로 메서드니깐 메서드를 정의하듯이 기능을 적어준다

ex) 
package javaStudy;

public interface TV{
	public void turnOn();
	public void turnOff();
	public void changeVolume( int volume );
	public void changeChannel( int channel1 );
}

>> 이후에 TV의 볼륨을 0~100까지만 조절하려고 함
public int MIN_VOLUME = 0;
public int MAX_VOLUME = 100;
을 적어줌 

44강 인터페이스 사용하기
인터페이스 적용을 위해 새로운 class를 생성
class 생성 시 Interface 의 Add 버튼을 눌러서 interface 검색 후 골라준다

실행결과 )
public class LedTV implements TV {
	
	@override
	public void turnOn() {
		System.out.println("켜다");
	}

	@override
	public void turnOn() {
		System.out.println("끄다");
	}

	@override
	public void changeVolume( int volume ) {
		System.out.println("불륨을 조절하다");
	}

	@override
	public void changeChannel( int channel ) {
		System.out.println("채널을 변경하다");
	}
}

구현 선언)
public class LedExam{
	public static void main(String[ ] args) {
		TV tv = new LedTV();
		tv.turnOn();
		tv.changeVolume(8);
		tv.changeChannel(39);
		tv.turnoff();
	}
}

실행 결과 모든 기능이 잘 실행된다
1. 참조 변수의 타입으로 인터페이스를 사용할 수 있다 >> String, class
2. 인터페이스가 가진 메서드만 사용할 수 있다

만약 LedTV에서 TV 인터페이스에 없는 기능을 확장해 사용하려면 어떻게 해야하나
>> 클래스 형변환을 이용하면 된다

45강 인터페이스의 default 메서드

기존에 인터페이스는 추상 메서드만 가질 수 있었다
자바8부터는 default 메서드와 static 메서드를 정의할 수 있도록 변경함

***
default 메서드 >> 인터페이스를 default 키워드로 선언하면 메서드를 구현할 수 있다
그리고 이를 구현한 클래스에서는 default 메서드를 오버라이딩 할 수도 있다

static 메서드도 같은 이치 
>> static 메서드는 반드시 인터페이스명.메서드명 (); 형식으로 호출해야 사용가능
ex) Calculator.exe2(); 

46강 내부 클래스
내부 클래스란? 클래스 안에 선언한 클래스를 말한다
특정 클래스 내에서만 사용하는 클래스를 내부 클래스로 선언한다

1. 인스턴스 클래스 > instance class
>> 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 선언하는 경우
ex)
public class InnerExam1 {
 class Cal {
	int value = 0;
	public void plus() {
		value++;
	}	
}
>> 사용하려면 반드시 InnerExam1 이라는 클래스가 먼저 만들어져야 한다

(main문)
public static void main(String [ ] args) {
	InnerExam1 t = new InnerExam1 ( );
	InnerExam1. Cal cal = t.new Cal();
	cal.plus();
	System.out.println(cal.value);


2. 스태틱 클래스 > static class
첫번째 클래스와 비슷한데 정적 필드, 즉 static한 필드로 선언한 경우 
이 경우에는 static한 필드이기 때문에 InnerExam2 객체를 생성할 필요가 없다
ex)
public class IneerExam2{
	static class Cal{
		int value = 0;
		public void plus() {
			value++;
		}
	}

public static void main (String [ ]  args) {
	InnerExam2.Cal cal = new InnerExam2.cal();
	}
}
사용방법 > new InnerExam2.클래스명 () ;

3. 지역 클래스 > local class
내부 클래스를 인스턴스 변수로 선언하는 것이 아니라 메서드 안에 선언하는 것

ex) 
public class InnerExam3{
	public void exec() {  // 메서드임
		class Cal {
		int value = 0;
		public void plus ( ) {
			value++;
			}
		}

		Cal cal = new Cal ();
		cal.plus();
		System.out.println(cal.value);
	}
	public static void main ( String[ ] args ) {
		InnerExam3 t = new InnerExam3( );
		t.exec( );
	}
}
>> 매서드 안에서 Cal 객체를 생성하고, Cal 객체가 가진 메서드를 호출하거나
cal이 가진 value를 호출해 사용할 수 있다

47강 익명 클래스 

익명 클래스 > anoymous class



48강 예외처리
ex)
public class ExceptionExam {

	public static void main(String[] args) {
		int i = 10;
		int j = 0;  // 0 division 으로 예외처리 되는 부분
		int k = i/j;
		System.out.println(k);
		System.out.println("main end!!");
	}
}

예외처리 된 부분 뒤에 정상적인 코드가 있어도 예외 처리 된 부분 뒤에는 실행되지 못 함

자바는 예외를 처리할 수 있는 문법을 제공한다
앞의 ex로 말하면 프로그래머는 j라는 변수에 0이 들어올지 모르는 에외사항을 미리 예측하고 
처리할 수 있다
이렇게 처리하는 것을 "예외처리"라고 한다

예외처리하는 문법 >> try-catch-finally 문을 사용한다

선언방법
try{
	수행할 코드, 예외 발생 가능성이 있는 블록
} catch ( 발생할 수 있는 예외 타입 변수명 ) {
	예외처리 블록 
} finally {
	예외 발생 여부와 상관없이 무조건 실행하는 블록(생략가능)
}

원래 수행할 코드는 try 블록에 있음
try 블록에서 예외가 발생하면 발생한 지점부터 try블록 마지막까지는 실행할 수 없다
catch 블록으로 넘어옴. 이때 발생한 예외와 catch 블록에 선언해놓은 예외가 맞아야
해당 catch 블록이 실행된다 
따라서 try 블록이나 catch 블록이 반드시 실행할 거라고 예측할 수는 없다
실행할수도 있고 안할수도 있는데 이래서 finally 블록이 중요함
finally 블록은 반드시 실행한다
예외 발생 여부와 상관없이 반드시 실행하는 구문이 finally
>> 그런 부분이 없다면 생략해도 괜찮다

49강 Throws
>> 예외처리를 해당 메서드를 호출한 쪽으로 던지는 throws 

예외처리를 하지 않고 특정 메서드를 호출한 쪽에 에외를 처리하라고 넘길 수 있다
즉, 내가 처리하지 않고 호출한쪽에서 처리하라고 넘길 수 있는 키워드가 thorws

이 메서드에서 발생하는 오류를 메서드 내에서 처리하지 않고 메서드를 호출한 쪽에서
처리할 수 있도록 한 것이다

이때도 예외를 하나만 넘길 수 있는 것이 아니라 다음과 같이 ,(콤마)를 사용해 예외처리를
여러개 보낼 수도 있다

혹은 49장처럼 Exception이라고 하면 모든 Exception의 상위 클래스이므로 throws Exception
이라고 넘겨주면 이 메서드에서 발생하는 모든 예외를 넘길 수 있다

선언
메서드 선언부 뒤쪽에 'throws + 발생할 예외'를 적는다

51강 Exception 발생시키기
>> 강제로 오류를 발생시키는 throw
throw는 보통 오류를 떠넘기는 thorws (s들어가 있음) 와 같이 사용한다























