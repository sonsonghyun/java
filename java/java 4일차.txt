36강 패키지
패키지는 클래스를 관리하는데 사용한다
자바도 관련한 클래스를 폴더별로 관리한다 
이 때 사용하는 키워드가 패키지이다
ex)
package 패키지명;
public class 클래스명 {
---코드---
}

패키지명은 보통 도메인명을 거꾸로 적은 후 프로젝트명을 붙여서 사용한다
그 이유는 다른 프로젝트나 다른회사, 다른 프로그램명과 중복되지 않기 위해서이다

다른 패키지에 들어있는 클래스를 사용하려면 import 키워들르 사용해야 한다
이클립스에서는 Ctrl + shift + o 를 눌러서 import문을 추가할 수 있다
import 하지 않으면 일일이 앞에 패키지명을 써줘야 해서 불편함

37강 상속
상속이란 부모가 자식에게 가진 것을 물려주는 것을 의미한다

class를 생성할 때 이름을 입력하고 아래를 보면
Superclass라는 부분이 있다. 여기에 상속받고 싶은 클래스를 찾아 넣는다
Browse를 눌러 Superclass Selection 창을 연 뒤 Choose a type 칸에 
상속받고 싶은 클래스명을 넣어서 사용한다

클래스를 생성하면 나오는 code)
package javaStudy;

public class Bus extends Car{

}

코드를 보면 extends Car라고 자동으로 붙어있다 
자바에서 extends라는 키워드와 클래스명을 사용하면 부모 클래스가 가진 것을 상속받을 수 있다

상속방법)
public class 클래스명 extends 부모 클래스명

code)
public class Car {
	
	public void run(){
		System.out.println("달리다");
	}
}

code2)
public class BusExam {

	public static void main(String[] args) {
		Bus bus = new Bus();
		bus.run();
	}

}

Bus클래스에는 아무런 메서드도 정의하지 않았지만 Car 클래스를 상속받음으로써 Car라는 
부모 클래스가 가진 run 메서드를 사용할 수 있습니다
Bus 클래스에 다른 메서드를 추가하고 BusExam에서 실행하면 실행이 된다
이렇게 부모가 가진 메서드 외에 추가로 메서드를 선언하는 것을 '확장한다'고 합니다
***
하지만 부모클래스가 자식클래스의 메서드는 사용할 수 없다

38강 접근 제한자
수학과 관련한 클래스라면 수학과 관련한 속성이나 메서드를, 날짜와 관련한 클래스라면 날짜와 관련한
속성이나 메서드를 가지고 있어야한다. 이렇게 관련 내용을 모아서 가지는 것을 "캡슐화"라고 한다

캡슐화된 필드와 메서드 중에는 외부에 노출하지 않고 감추고 싶은 속성이나 메서드도 있을것이다
이런경우 사용하는 것이 "접근 제한자"이다

***접근 제한자 종류***
1. public
>> 어떤 클래스든 접근 할 수 있다
2. protected
>> 모든 접근이 아니라 같은 패키지인 경우만 접근을 허용한다
단, 다른 패키지라도 상속받은 경우에는 접근을 허용한다
3. private
>> 자기 자신만 접근할 수 있다
4. 아무것도 적지않고 선언
>> 이 경우 default 접근 지정자를 가졌다고 한다
자기 자신과 같은 패키지 내에서 접근 할 수 있음을 의미한다
자기자신 & 자기 자신과 같은 패키지 안에서 접근을 허용

범위순으로 보면
public > protected > default > private

위의 범위를 위반하면 컴파일 에러가 발생한다

39강 추상 클래스

어떻게 만들어야 할지 감이 안오는 추상적인 것을 정의할 때 추상 클래스를 사용한다
추상 클래스는 부모로 수행할 수 있고, 객체는 될 수 없습니다. 구체적인 클래스만 객체가 될 수 있다

추상 클래스인것을 나타내는 키워드는 abstract
그런데 메서드가 하나라도 추상 메서드면 해당 클래스는 추상클래스가 될 수 밖에 없다
따라서 클래스 앞에도 추상 클래스라는 의미로 abstract 키워드를 붙여준다

그러면 추상 클래스는 추상 메서드만 가질 수 있는가?? NO
일반 메서드도 가질 수 있다

추상 클래스 정의하기)
1. 추상 클래스는 클래스 앞에 abstract 키워드를 넣어 정의한다
2. 추상 클래스는 미완성의 추상 메서드를 포함할 수 있다
- 추상 메서드란 내용이 없는 메서드다. 즉, 구현되지 않은 메서드이다
- 추상 메서드는 리턴형 앞에 abstract 키워드를 붙여야 한다
3. 추상 메서드는 객체를 생성할 수 없다

40강 super 와 부모 생성자
ex1)
	public Car() {
		System.out.println("Car의 기본 생성자입니다");
	}

ex2)
public class Truck extends Car {
	public Truck(){
		System.out.println("Truck의 기본 생성자입니다");
	}

}

ex3)
public class TruckExam {

	public static void main(String[] args) {
		Truck t = new Truck();
	}
}

코드 실행시 Car의 메서드와 Truck의 메서드가 둘 다 작동한다
이유는 new라는 키워드로 Truck을 생성하면 이 Truck이 메모리에 올라갈 때, 
즉 Truck이 인스턴스화될 때 부모인 Car객체도 인스턴스화 된다 
Car객체가 먼저 생성되어야만 Truck 객체도 생성된다

생성자는 객체를 초기화한다. 생성자가 호출될 때 자동으로 부모의 생성자가 호출되면서
부모 객체를 초기화한다. 부모의 생성자를 호출할 때는 부모 객체를 나타내는 super라는 
키워드를 사용한다. 
super() 를 붙이면 부모 생성자가 호출된다

나를 가리키는 키워드가 this였으면 부모를 가리키는 키워드는 super이다

Truck의 객체가 생성되기 위해서는 반드시 부모 객체가 먼저 생성되어야 하는데
부모 생성자를 직접호출 하지 않으면 컴파일러는 기본생성자만 호출한다
그런데 부모클래스에 기본 생성자가 없으므로 Truck 클래스 자체에 에러가 발생한 것이다
이럴 때는 프로그래머가 직접 기본 생성자를 호출해야 에러가 발생하지 않는다
이때 super라는 키워드를 사용해야 한다

super 키워드는 자식이 부모의 메서드나 필드를 사용할 때도 사용할 수 있다

41강 오버라이딩
오버라이딩이란? 
부모가 가진 메서드와 똑같은 모양의 메서드를 자식이 가지는 것을 말한다
부모가 물려준 기능 중 필요한 기능은 내가 사용하지만 
새로운 기능이 더 생겼을 때와 같은 경우에는 부모가 물려준 메서드를
자식 클래스에서 재정의해 사용하는 것이 오버라이딩

'재정의'한다고 해서 부모 클래스의 메서드가 아에 사라지는게 아니다
부모 클래스의 메서드를 아예 사용하지 않는 것이 아니라 
사용하면서 특정 부분만 추가하고 싶은 경우가 있다
이럴 때는 super를 사용한다 

42강 클래스 형 변환
기본형의 형을 바꾸었듯이 클래스형의 형도 바꿀 수 있다
ex)
Car car = new Van( ) ;

Car를 가리키겠다고 선언한 car형 변수인데, Van을 가리키고 있다
그러나 어떠한 오류도 발생하지 않음
묵시적으로 형변환이 일어난 경우이다

형변환은 두가지
첫째, 묵시적(암묵적) 형변환 > 더 큰 그릇에 작은 그릇의 값을 담는 경우
둘째, 명시적 형변환 > 작은 그릇에 큰 그릇의 값을 담는 경우

객체들 사이에 상속이 일어나면 부모형 그릇에 그 부모를 상속받은 자식들, 
혹은 그 자식들도 모두 담을 수 있다

기본자료형 변수는 직접 값을 담고 있으므로 담는 다는 표현이 맞지만,
참조 자료형은 실제 값이 아니라 주소를 가지므로 '가리킨다'고 표현하는 것이 맞다

부모타입으로 자식을 가리킬 수는 있지만 
부모 타입으로 자식을 가리켰을 때는 부모가 가진 메서드만 사용 가능하다

But 형변환을 사용하면 자식의 메서드도 사용가능하다
ex)
Car c = new Van( );

Van van = c;

Van van = (Van) c;



























